// Autogenerated from jj->javascript transpiler
// jshint esversion: 6
(function() {
"use strict";

//// Runtime support

function importUri(stack, uri) {
  if (!moduleCache[uri]) {
    if (!uriTable[uri]) {
      throw new Error("No such module with uri: " + uri);
    }
    const exports = Object.create(null);
    uriTable[uri](stack, exports);
    moduleCache[uri] = exports;
  }
  return moduleCache[uri];
}

function importPackage(stack, pkg) {
  if (!packageTable[pkg]) {
    throw new Error("No such package: " + pkg);
  }
  return importUri(stack, packageTable[pkg]);
}

function displayError(e, stackOrSnapshot, additionalMessage) {
  console.error("***************************");
  console.error("********** ERROR **********");
  console.error("***************************");
  if (additionalMessage) {
    console.error("*** " + additionalMessage + " ***");
  }
  console.error(getStackTraceMessageFromStack(stackOrSnapshot));
  console.error(e);
}

function resolvePromisePool(promisePool) {
  const resolvePromise = promise => promise.then(() => null, error => {
    displayError(error, promise.stackSnapshot, "Promise never awaited on");
  });
  for (const promise of Array.from(promisePool)) {
    resolvePromise(promise);
  }
}

function tryAndCatch(f) {
  const stack = [];
  stack.isAsync = false;
  stack.promisePool = new Set();
  try {
    f(stack);
  } catch (e) {
    displayError(e, stack);
  } finally {
    resolvePromisePool(stack.promisePool);
  }
}

function padstr(str, len) {
  return str.length < len ? str + " ".repeat(len-str.length) : str;
}

function getStackTraceMessageFromStack(stack) {
  let message = "Most recent call last:";
  for (const index of stack) {
    const [context, uri, lineno] = debugInfo[index].split("@");
    message += "\n  " + padstr(context, 25) +
               padstr("file '" + uri + "'", 20) +
               padstr("line " + lineno, 10);
  }
  message += "\n--- end of stack trace ---";
  return message;
}

function popStack(stack, value) {
  stack.pop();
  return value;
}

// Behaves significatly different from A+ promises.
const statePending = 0;
const stateResolved = 1;
const stateRejected = 2;
class MockPromise {
  constructor(stack, resolver) {
    // Add this to the promise pool, so that when the promise pool
    // gets cleaned up, we can throw.
    stack.promisePool.add(this);

    this.state = statePending;
    this.callbacksSet = false;
    this.onResolve = null;
    this.onReject = null;
    this.promisePool = stack.promisePool;
    this.result = null;

    // Not sure if I want to copy the entire stack every time
    // I create a new promise.
    // However, I think this will be really useful for situations where
    // I forget to 'await' on promises.
    this.stackSnapshot = Array.from(stack);
    this.stackReference = stack;

    resolver(result => this.resolve(result), err => this.reject(err));
  }
  assertPending() {
    if (this.state !== statePending) {
      throw new Error("Resolve/reject called more than once on this promise");
    }
  }
  then(onResolve, onReject) {
    if (this.callbacksSet) {
      throw new Error("'then' called more than once on this promise");
    }
    this.promisePool.delete(this);
    this.callbacksSet = true;
    this.onResolve = onResolve;
    this.onReject = onReject;
    if (this.state === stateResolved) {
      onResolve(this.result);
    } else if (this.state === stateRejected) {
      onReject(this.result);
    }
  }
  resolve(result) {
    this.assertPending();
    this.state = stateResolved;
    this.result = result;
    if (this.callbacksSet) {
      this.onResolve(result);
    }
  }
  reject(reason) {
    this.assertPending();
    this.state = stateRejected;
    this.result = reason;
    if (this.callbacksSet) {
      this.onReject(reason);
    }
  }
}

function asyncf(generator) {
  return function() {
    const args = [];
    // If you are calling an async function from a synchronous context,
    // we should start a new context.
    // Also include the last frame of synchronous context to document
    // where this asynchronous instance came from.
    const stack = arguments[0];
    const startNewContext = !stack.isAsync;
    const newStack = startNewContext ? [stack[stack.length-1]] : stack;
    if (startNewContext) {
      newStack.isAsync = true;
      newStack.promisePool = new Set();
      args.push(newStack);
    } else {
      args.push(arguments[0]);
    }
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    const generatorObject = generator.apply(this, args);
    const promise = new MockPromise(newStack, (resolve, reject) => {
      asyncfHelper(generatorObject, resolve, reject);
    });
    if (startNewContext) {
      promise.then(result => {
        resolvePromisePool(newStack.promisePool);
      }, e => {
        // startNextContext promise is always considered to have been
        // 'awaited' upon. As such, we use stackReference here instead of
        // stackSnapshot which is only reserved for promises that were
        // never awaited on.
        displayError(e, promise.stackReference);
        resolvePromisePool(newStack.promisePool);
      });
    }
    return promise;
  }
}

function asyncfHelper(generatorObject, resolve, reject, val, thr) {
  try {
    let value, done;
    if (thr) {
      ({value, done} = generatorObject.throw(val));
    } else {
      ({value, done} = generatorObject.next(val));
    }
    if (done) {
      resolve(value);
      return;
    } else {
      value.then(result => {
        asyncfHelper(generatorObject, resolve, reject, result);
      }, e => {
        asyncfHelper(generatorObject, resolve, reject, e, true);
      });
    }
  } catch (e) {
    reject(e);
  }
}

//// Builtins

function jjlen(stack, xs) {
  if (Array.isArray(xs)) {
    return xs.length;
  }
}


const moduleCache = Object.create(null);
const debugInfo = ["??@??@??",".print@sample.jj@2",".@sample.jj@5",".@sample.jj@6",".syncFunc@sample.jj@9",".asyncFunc@sample.jj@13",".asyncFunc@sample.jj@14",".asyncFunc@sample.jj@15",".asyncMain@sample.jj@19",".asyncMain@sample.jj@20",".asyncMain@sample.jj@21",".@sample.jj@24",".@sample.jj@25",".@sample.jj@26"];
const packageTable = Object.create(null);
const uriTable = Object.create(null);
uriTable["sample.jj"] = function(stack, uri) {
  const jjprint = function jjprint(stack,jjx)
  {
    (stack.push(1),popStack(stack,console.log(jjx)));
  };
  (stack.push(2),popStack(stack,jjprint(stack,"Hello world!")));
  (stack.push(3),popStack(stack,jjprint(stack,jjlen(stack,[1,2,3]))));
  const jjsyncFunc = function jjsyncFunc(stack)
  {
    (stack.push(4),popStack(stack,jjfoo(stack)));
  };
  const jjasyncFunc = asyncf(function* jjasyncFunc(stack)
  {
    (stack.push(5),popStack(stack,jjprint(stack,"before foo")));
    (stack.push(6),popStack(stack,jjsyncFunc(stack)));
    (stack.push(7),popStack(stack,jjprint(stack,"after foo")));
  });
  const jjasyncMain = asyncf(function* jjasyncMain(stack)
  {
    (stack.push(8),popStack(stack,jjprint(stack,"Starting asyncMain!")));
    (stack.push(9),popStack(stack,(yield jjasyncFunc(stack))));
    (stack.push(10),popStack(stack,jjprint(stack,"After asyncFunc!")));
  });
  (stack.push(11),popStack(stack,jjprint(stack,"Before starting asyncMain from a synchronous context")));
  (stack.push(12),popStack(stack,jjasyncMain(stack)));
  (stack.push(13),popStack(stack,jjprint(stack,"After starting asyncMain from a synchronous context")));
};
tryAndCatch(stack => importUri(stack, "sample.jj"));
})();
