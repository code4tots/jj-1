// Autogenerated from jj->javascript transpiler
// jshint esversion: 6
(function() {
"use strict";

//// Runtime support

function importUri(stack, uri) {
  if (!moduleCache[uri]) {
    if (!uriTable[uri]) {
      throw new Error("No such module with uri: " + uri);
    }
    const exports = Object.create(null);
    exports.toString = () => "<module '" + uri + "'>";
    uriTable[uri](stack, exports);
    moduleCache[uri] = exports;
  }
  return moduleCache[uri];
}

function importPackage(stack, pkg) {
  if (!packageTable[pkg]) {
    throw new Error("No such package: " + pkg);
  }
  return importUri(stack, packageTable[pkg]);
}

function displayError(e, stackOrSnapshot, additionalMessage) {
  console.error("***************************");
  console.error("********** ERROR **********");
  console.error("***************************");
  if (additionalMessage) {
    console.error("*** " + additionalMessage + " ***");
  }
  console.error(getStackTraceMessageFromStack(stackOrSnapshot));
  console.error(e);
}

function resolvePromisePool(promisePool) {
  const resolvePromise = promise => promise.then(() => null, error => {
    displayError(error, promise.oldStack, "Promise never awaited on");
  });
  for (const promise of Array.from(promisePool)) {
    resolvePromise(promise);
  }
}

function tryAndCatch(f) {
  const stack = [];
  stack.promisePool = new Set();
  try {
    f(stack);
  } catch (e) {
    displayError(e, stack);
  } finally {
    resolvePromisePool(stack.promisePool);
  }
}

function padstr(str, len) {
  return str.length < len ? str + " ".repeat(len-str.length) : str;
}

function getStackTraceMessageFromStack(stack) {
  let message = "Most recent call last:";
  for (const index of stack) {
    const [context, uri, lineno] = debugInfo[index].split("@");
    message += "\n  " + padstr(context, 25) +
               padstr("file '" + uri + "'", 20) +
               padstr("line " + lineno, 10);
  }
  message += "\n--- end of stack trace ---";
  return message;
}

function popStack(stack, value) {
  stack.pop();
  return value;
}

// Behaves significatly different from A+ promises.
const statePending = 0;
const stateResolved = 1;
const stateRejected = 2;
class MockPromise {
  constructor(oldStack, newStack, resolver) {
    // Add this to the promise pool, so that when the promise pool
    // gets cleaned up, we can throw.
    oldStack.promisePool.add(this);

    this.state = statePending;
    this.callbacksSet = false;
    this.onResolveCallback = null;
    this.onRejectCallback = null;
    this.promisePool = oldStack.promisePool;
    this.result = null;

    // Not sure if I want to copy the entire stack every time
    // I create a new promise.
    // However, I think this will be really useful for situations where
    // I forget to 'await' on promises.
    this.oldStack = Array.from(oldStack);
    this.newStack = newStack;

    resolver(result => this.resolve(result), err => this.reject(err));
  }
  assertPending() {
    if (this.state !== statePending) {
      throw new Error("Resolve/reject called more than once on this promise");
    }
  }
  then(onResolveCallback, onRejectCallback) {
    if (this.callbacksSet) {
      throw new Error("'then' called more than once on this promise");
    }
    this.promisePool.delete(this);
    this.callbacksSet = true;
    this.onResolveCallback = onResolveCallback;
    this.onRejectCallback = onRejectCallback;
    if (this.state === stateResolved) {
      this.onResolve(this.result);
    } else if (this.state === stateRejected) {
      this.onReject(this.result);
    }
  }
  resolve(result) {
    this.assertPending();
    this.state = stateResolved;
    this.result = result;
    if (this.callbacksSet) {
      this.onResolve(result);
    }
  }
  reject(reason) {
    this.assertPending();
    this.state = stateRejected;
    this.result = reason;
    if (this.callbacksSet) {
      this.onReject(reason);
    }
  }
  onResolve(result) {
    this.cleanup();
    this.onResolveCallback(result);
  }
  onReject(reason) {
    this.cleanup();
    this.onRejectCallback(reason);
  }
  cleanup() {
    resolvePromisePool(this.newStack.promisePool);
  }
}

function asyncf(generator) {
  return function() {
    const args = [];
    // If you are calling an async function from a synchronous context,
    // we should start a new context.
    // Also include the last frame of synchronous context to document
    // where this asynchronous instance came from.
    const oldStack = arguments[0];

    // NOTE: Before I only started a new context if we were going from
    // a synchronous context to an asynchronous one. However, I realized
    // that that wasn't good enough -- if you call multiple async
    // functions without awaiting on each before going on to the next,
    // they are going to have to share the call stack, and it's going to get
    // clobbered. The fix I decided on was to create a new stack trace
    // for every call to an async function.
    const newStack = [oldStack[oldStack.length-1]];
    newStack.promisePool = new Set();
    args.push(newStack);
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    const generatorObject = generator.apply(this, args);
    const promise = new MockPromise(oldStack, newStack, (resolve, reject) => {
      asyncfHelper(generatorObject, resolve, reject);
    });
    return promise;
  };
}

function asyncfHelper(generatorObject, resolve, reject, val, thr) {
  try {
    let value, done;
    if (thr) {
      ({value, done} = generatorObject.throw(val));
    } else {
      ({value, done} = generatorObject.next(val));
    }
    if (done) {
      resolve(value);
      return;
    } else {
      value.then(result => {
        asyncfHelper(generatorObject, resolve, reject, result);
      }, e => {
        asyncfHelper(generatorObject, resolve, reject, e, true);
      });
    }
  } catch (e) {
    reject(e);
  }
}

//// Builtins

class jjObject {
  aa__str__(stack) {
    return this.aa__repr__(stack);
  }
  aa__repr__(stack) {
    return "<" + this.constructor.name + " instance>";
  }
}

function jjsplit(stack, str, delimiter) {
  delimiter = delimiter === undefined ? /s+/ : delimiter;
}

function jjrepr(stack, x) {
  if (x instanceof jjObject) {
    return x.aa__repr__(stack);
  } else if (typeof x === "string") {
    return JSON.stringify(x);
  } else {
    return "" + x;
  }
}

function jjstr(stack, x) {
  if (x instanceof jjObject) {
    return x.aa__str__(stack);
  } else {
    return "" + x;
  }
}

function jjlen(stack, xs) {
  if (Array.isArray(xs) || typeof xs === "string") {
    return xs.length;
  } else {
    throw new Error("No len for " + xs);
  }
}

function jjerror(stack, message) {
  throw new Error(message);
}

function jjgetStackTraceMessage(stack) {
  return getStackTraceMessageFromStack(stack);
}

function op__eq__(stack, a, b) {
  if (a === null || a === undefined || typeof a === "boolean" ||
      typeof a === "number" || typeof a === "string") {
    return a === b;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!Array.isArray(b) || len !== b.length) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (!op__eq__(stack, a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return a.aa__eq__(stack, b);
}

function op__ne__(stack, a, b) {
  return !op__eq__(stack, a, b);
}

function op__lt__(stack, a, b) {
  if (typeof a === "boolean" || typeof a === "number" ||
      typeof a === "string") {
    return a < b;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      throw new Error("Tried to compare Array with non-Array: " + b);
    }
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
      if (op__lt__(stack, a[i], b[i])) {
        return true;
      } else if (op__lt__(stack, b[i], a[i])) {
        return false;
      }
    }
    return a.length < b.length;
  }
  return a.aa__lt__(stack, b);
}

function op__getitem__(stack, owner, key) {
  if (Array.isArray(owner) && typeof key === "number") {
    return owner[key];
  }
  return owner.aa__getitem__(stack, key);
}

function op__setitem__(stack, owner, key, value) {
  if (Array.isArray(owner) && typeof key === "number") {
    return (owner[key] = value);
  }
  return owner.aa__setitem__(stack, key, value);
}


const moduleCache = Object.create(null);
const debugInfo = ["??@??@??",".print@<prelude>@4",".assert@<prelude>@8",".assert@<prelude>@9",".assertEqual@<prelude>@14",".assertEqual@<prelude>@15",".@canvasdemo.jj@3",".@canvasdemo.jj@4",".@canvasdemo.jj@5",".@canvasdemo.jj@8",".@canvasdemo.jj@11",".@canvasdemo.jj@14",".@canvasdemo.jj@15",".@canvasdemo.jj@16",".@canvasdemo.jj@17",".@canvasdemo.jj@18",".@canvasdemo.jj@21",".@canvasdemo.jj@22",".@canvasdemo.jj@23",".@canvasdemo.jj@25",".@canvasdemo.jj@26",".@canvasdemo.jj@27",".@canvasdemo.jj@28",".@canvasdemo.jj@29",".@canvasdemo.jj@30"];
const packageTable = Object.create(null);
packageTable["simple.canvas"] = "lib\\htmlcanvas.js";
packageTable["canvasdemo.jj"] = "canvasdemo.jj";
const uriTable = Object.create(null);
uriTable["lib\\htmlcanvas.js"] = function(stack, exports) {
// jj package: simple.canvas
// jshint esversion: 6

class Canvas extends jjObject {
  constructor(stack) {
    super();
    const canvas = document.createElement("canvas");
    if (!canvas.getContext) {
      throw new Error("Canvas element not supported!");
    }
    this.dom = canvas;
    this.ctx = canvas.getContext("2d");
    canvas.setAttribute("width", 300);
    canvas.setAttribute("height", 300);
    canvas.style.outline = "thin solid blue";
    canvas.style.margin = "auto";
    canvas.style.position = "absolute";
    canvas.style.top = 0;
    canvas.style.bottom = 0;
    canvas.style.right = 0;
    canvas.style.left = 0;
  }
  aagetWidth(stack) {
    return this.dom.width;
  }
  aagetHeight(stack) {
    return this.dom.height;
  }
  aasetWidth(stack, width) {
    this.dom.width = width;
  }
  aasetHeight(stack, height) {
    this.dom.height = height;
  }
  aasetFillStyle(stack, style) {
    this.ctx.fillStyle = style;
  }
  aasetStrokeStyle(stack, style) {
    this.ctx.strokeStyle = style;
  }
  aafillRect(stack, x, y, width, height) {
    this.ctx.fillRect(x, y, width, height);
  }
  aasetFont(stack, font) {
    this.ctx.font = font;
  }
  aafillText(stack, text, x, y, maxWidth) {
    this.ctx.fillText(text, x, y, maxWidth);
  }
  aagetTextWidth(stack, text) {
    return this.ctx.measureText(text).width;
  }
}

function installCanvas(stack, canvas) {
  document.body.appendChild(canvas.dom);
}

exports.aaCanvas = Canvas;
exports.aainstallCanvas = installCanvas;

};
uriTable["canvasdemo.jj"] = function(stack, exports) {
  const jjlibcanvas = importPackage(stack, 'simple.canvas');
  (stack.push(6),popStack(stack," create a new canvas element and add it to the document "));
  let jjcanvas = (stack.push(7),popStack(stack,new (jjlibcanvas.aaCanvas)(stack)));
  (stack.push(8),popStack(stack,jjlibcanvas.aainstallCanvas(stack,jjcanvas)));
  (stack.push(9),popStack(stack," setting width\r\nBy default, both width and height are 300px.\r\n"));
  (stack.push(10),popStack(stack,jjcanvas.aasetWidth(stack,600)));
  (stack.push(11),popStack(stack," drawing rectangles "));
  (stack.push(12),popStack(stack,jjcanvas.aasetFillStyle(stack,"rgb(200, 0, 0)")));
  (stack.push(13),popStack(stack,jjcanvas.aafillRect(stack,10,10,50,50)));
  (stack.push(14),popStack(stack,jjcanvas.aasetFillStyle(stack,"rgba(0, 0, 200, 0.5)")));
  (stack.push(15),popStack(stack,jjcanvas.aafillRect(stack,30,30,50,50)));
  (stack.push(16),popStack(stack," drawing text "));
  (stack.push(17),popStack(stack,jjcanvas.aasetFont(stack,"48px serif")));
  (stack.push(18),popStack(stack,jjcanvas.aafillText(stack,"Hello world!",10,150)));
  {
    (stack.push(19),popStack(stack,jjcanvas.aasetFillStyle(stack,"rgb(0, 200, 0)")));
    (stack.push(20),popStack(stack,jjcanvas.aasetFont(stack,"24px serif")));
    let jjwidthstr = (stack.push(21),popStack(stack,("Width = "+jjstr(stack,jjcanvas.aagetWidth(stack)))));
    (stack.push(22),popStack(stack,jjcanvas.aafillText(stack,jjwidthstr,10,175)));
    let jjtextwidth = (stack.push(23),popStack(stack,jjcanvas.aagetTextWidth(stack,jjwidthstr)));
    (stack.push(24),popStack(stack,jjcanvas.aafillText(stack,(", Height = "+jjstr(stack,jjcanvas.aagetHeight(stack))),(10+jjtextwidth),175)));
  }
  exports.aacanvas = jjcanvas;
};
// this is a mock stack to run the builtin prelude
const stack = [];
const jjprint = function jjprint(stack,jjx)
{
  (stack.push(1),popStack(stack,console.log(jjstr(stack,jjx))));
};
const jjassert = function jjassert(stack,jjx,jjmessage)
{
  if ((stack.push(2),popStack(stack,(!jjx))))
  {
    (stack.push(3),popStack(stack,jjerror(stack,("Assertion error: "+(jjmessage?jjmessage:"")))));
  }
};
const jjassertEqual = function jjassertEqual(stack,jja,jjb,jjmessage)
{
  if ((stack.push(4),popStack(stack,op__ne__(stack,jja,jjb))))
  {
    (stack.push(5),popStack(stack,jjerror(stack,((("Assert expected "+jjrepr(stack,jja))+" to equal ")+jjrepr(stack,jjb)))));
  }
};
tryAndCatch(stack => {
  importUri(stack, "canvasdemo.jj");
});
})();
