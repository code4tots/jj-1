// Autogenerated from jj->javascript transpiler
// jshint esversion: 6
(function() {
"use strict";

//// Runtime support

function importUri(stack, uri) {
  if (!moduleCache[uri]) {
    if (!uriTable[uri]) {
      throw new Error("No such module with uri: " + uri);
    }
    const exports = Object.create(null);
    uriTable[uri](stack, exports);
    moduleCache[uri] = exports;
  }
  return moduleCache[uri];
}

function importPackage(stack, pkg) {
  if (!packageTable[pkg]) {
    throw new Error("No such package: " + pkg);
  }
  return importUri(stack, packageTable[pkg]);
}

function displayError(e, stackOrSnapshot, additionalMessage) {
  console.error("***************************");
  console.error("********** ERROR **********");
  console.error("***************************");
  if (additionalMessage) {
    console.error("*** " + additionalMessage + " ***");
  }
  console.error(getStackTraceMessageFromStack(stackOrSnapshot));
  console.error(e);
}

function resolvePromisePool(promisePool) {
  const resolvePromise = promise => promise.then(() => null, error => {
    displayError(error, promise.oldStack, "Promise never awaited on");
  });
  for (const promise of Array.from(promisePool)) {
    resolvePromise(promise);
  }
}

function tryAndCatch(f) {
  const stack = [];
  stack.promisePool = new Set();
  try {
    f(stack);
  } catch (e) {
    displayError(e, stack);
  } finally {
    resolvePromisePool(stack.promisePool);
  }
}

function padstr(str, len) {
  return str.length < len ? str + " ".repeat(len-str.length) : str;
}

function getStackTraceMessageFromStack(stack) {
  let message = "Most recent call last:";
  for (const index of stack) {
    const [context, uri, lineno] = debugInfo[index].split("@");
    message += "\n  " + padstr(context, 25) +
               padstr("file '" + uri + "'", 20) +
               padstr("line " + lineno, 10);
  }
  message += "\n--- end of stack trace ---";
  return message;
}

function popStack(stack, value) {
  stack.pop();
  return value;
}

// Behaves significatly different from A+ promises.
const statePending = 0;
const stateResolved = 1;
const stateRejected = 2;
class MockPromise {
  constructor(oldStack, newStack, resolver) {
    // Add this to the promise pool, so that when the promise pool
    // gets cleaned up, we can throw.
    oldStack.promisePool.add(this);

    this.state = statePending;
    this.callbacksSet = false;
    this.onResolveCallback = null;
    this.onRejectCallback = null;
    this.promisePool = oldStack.promisePool;
    this.result = null;

    // Not sure if I want to copy the entire stack every time
    // I create a new promise.
    // However, I think this will be really useful for situations where
    // I forget to 'await' on promises.
    this.oldStack = Array.from(oldStack);
    this.newStack = newStack;

    resolver(result => this.resolve(result), err => this.reject(err));
  }
  assertPending() {
    if (this.state !== statePending) {
      throw new Error("Resolve/reject called more than once on this promise");
    }
  }
  then(onResolveCallback, onRejectCallback) {
    if (this.callbacksSet) {
      throw new Error("'then' called more than once on this promise");
    }
    this.promisePool.delete(this);
    this.callbacksSet = true;
    this.onResolveCallback = onResolveCallback;
    this.onRejectCallback = onRejectCallback;
    if (this.state === stateResolved) {
      this.onResolve(this.result);
    } else if (this.state === stateRejected) {
      this.onReject(this.result);
    }
  }
  resolve(result) {
    this.assertPending();
    this.state = stateResolved;
    this.result = result;
    if (this.callbacksSet) {
      this.onResolve(result);
    }
  }
  reject(reason) {
    this.assertPending();
    this.state = stateRejected;
    this.result = reason;
    if (this.callbacksSet) {
      this.onReject(reason);
    }
  }
  onResolve(result) {
    this.cleanup();
    this.onResolveCallback(result);
  }
  onReject(reason) {
    this.cleanup();
    this.onRejectCallback(reason);
  }
  cleanup() {
    resolvePromisePool(this.newStack.promisePool);
  }
}

function asyncf(generator) {
  return function() {
    const args = [];
    // If you are calling an async function from a synchronous context,
    // we should start a new context.
    // Also include the last frame of synchronous context to document
    // where this asynchronous instance came from.
    const oldStack = arguments[0];

    // NOTE: Before I only started a new context if we were going from
    // a synchronous context to an asynchronous one. However, I realized
    // that that wasn't good enough -- if you call multiple async
    // functions without awaiting on each before going on to the next,
    // they are going to have to share the call stack, and it's going to get
    // clobbered. The fix I decided on was to create a new stack trace
    // for every call to an async function.
    const newStack = [oldStack[oldStack.length-1]];
    newStack.promisePool = new Set();
    args.push(newStack);
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    const generatorObject = generator.apply(this, args);
    const promise = new MockPromise(oldStack, newStack, (resolve, reject) => {
      asyncfHelper(generatorObject, resolve, reject);
    });
    return promise;
  };
}

function asyncfHelper(generatorObject, resolve, reject, val, thr) {
  try {
    let value, done;
    if (thr) {
      ({value, done} = generatorObject.throw(val));
    } else {
      ({value, done} = generatorObject.next(val));
    }
    if (done) {
      resolve(value);
      return;
    } else {
      value.then(result => {
        asyncfHelper(generatorObject, resolve, reject, result);
      }, e => {
        asyncfHelper(generatorObject, resolve, reject, e, true);
      });
    }
  } catch (e) {
    reject(e);
  }
}

//// Builtins

class jjObject {
  aa__str__(stack) {
    return this.aa__repr__(stack);
  }
  aa__repr__(stack) {
    return "<" + this.constructor.name + " instance>";
  }
}

function jjsplit(stack, str, delimiter) {
  delimiter = delimiter === undefined ? /s+/ : delimiter;
}

function jjrepr(stack, x) {
  if (x instanceof jjObject) {
    return x.aa__repr__(stack);
  } else if (typeof x === "string") {
    return JSON.stringify(x);
  } else {
    return "" + x;
  }
}

function jjstr(stack, x) {
  if (x instanceof jjObject) {
    return x.aa__str__(stack);
  } else {
    return "" + x;
  }
}

function jjlen(stack, xs) {
  if (Array.isArray(xs) || typeof xs === "string") {
    return xs.length;
  } else {
    throw new Error("No len for " + xs);
  }
}

function jjerror(stack, message) {
  throw new Error(message);
}

function jjgetStackTraceMessage(stack) {
  return getStackTraceMessageFromStack(stack);
}

function op__eq__(stack, a, b) {
  if (a === null || a === undefined || typeof a === "boolean" ||
      typeof a === "number" || typeof a === "string") {
    return a === b;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!Array.isArray(b) || len !== b.length) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (!op__eq__(stack, a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return a.aa__eq__(stack, b);
}

function op__ne__(stack, a, b) {
  return !op__eq__(stack, a, b);
}

function op__lt__(stack, a, b) {
  if (typeof a === "boolean" || typeof a === "number" ||
      typeof a === "string") {
    return a < b;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      throw new Error("Tried to compare Array with non-Array: " + b);
    }
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
      if (op__lt__(stack, a[i], b[i])) {
        return true;
      } else if (op__lt__(stack, b[i], a[i])) {
        return false;
      }
    }
    return a.length < b.length;
  }
  return a.aa__lt__(stack, b);
}

function op__getitem__(stack, owner, key) {
  if (Array.isArray(owner) && typeof key === "number") {
    return owner[key];
  }
  return owner.aa__getitem__(stack, key);
}

function op__setitem__(stack, owner, key, value) {
  if (Array.isArray(owner) && typeof key === "number") {
    return (owner[key] = value);
  }
  return owner.aa__setitem__(stack, key, value);
}


const moduleCache = Object.create(null);
const debugInfo = ["??@??@??",".print@<prelude>@4",".assert@<prelude>@8",".assert@<prelude>@9",".assertEqual@<prelude>@14",".assertEqual@<prelude>@15",".@htmldemo.jj@5"];
const packageTable = Object.create(null);
packageTable["htmldemo.jj"] = "htmldemo.jj";
const uriTable = Object.create(null);
uriTable["htmldemo.jj"] = function(stack, uri) {
  (stack.push(6),popStack(stack,jjprint(stack,"Hi")));
};
// this is a mock stack to run the builtin prelude
const stack = [];
const jjprint = function jjprint(stack,jjx)
{
  (stack.push(1),popStack(stack,console.log(jjstr(stack,jjx))));
};
const jjassert = function jjassert(stack,jjx,jjmessage)
{
  if ((stack.push(2),popStack(stack,(!jjx))))
  {
    stack.push(3);popStack(stack,jjerror(stack,("Assertion error: "+(jjmessage?jjmessage:""))));
  }
};
const jjassertEqual = function jjassertEqual(stack,jja,jjb,jjmessage)
{
  if ((stack.push(4),popStack(stack,op__ne__(stack,jja,jjb))))
  {
    (stack.push(5),popStack(stack,jjerror(stack,((("Assert expected "+jjrepr(stack,jja))+" to equal ")+jjrepr(stack,jjb)))));
  }
};
tryAndCatch(stack => {
  importUri(stack, "htmldemo.jj");
});
})();
